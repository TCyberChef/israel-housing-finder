---
phase: 03-yad2-scraper
plan: 04
type: execute
wave: 4
depends_on: ["03-03"]
files_modified:
  - src/scrapers/index.ts
  - src/scrapers/db/client.ts
  - src/scrapers/db/operations.ts
  - .github/workflows/scrape-yad2.yml
  - package.json
user_setup:
  - service: supabase
    why: "Database write access for scraper"
    env_vars:
      - name: SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API -> Project URL"
      - name: SUPABASE_SERVICE_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> service_role secret (NOT anon key)"
    dashboard_config:
      - task: "Add GitHub Secrets for scraper workflow"
        location: "GitHub repo -> Settings -> Secrets and variables -> Actions -> New repository secret"
        details: "Add SUPABASE_URL and SUPABASE_SERVICE_KEY secrets"
autonomous: true

must_haves:
  truths:
    - "GitHub Actions workflow runs scraper every 6 hours"
    - "Scraped listings insert into database with dedupe_hash deduplication"
    - "Duplicate listings (same dedupe_hash) update last_seen timestamp"
    - "Stale listings (7+ days old) are marked inactive via is_active=false"
    - "Source attribution uses sources JSONB array format from Phase 2 schema"
    - "Workflow completes without errors when secrets are configured"
  artifacts:
    - path: "src/scrapers/index.ts"
      provides: "Entry point for scraper execution"
      exports: ["main"]
      min_lines: 30
    - path: "src/scrapers/db/client.ts"
      provides: "Supabase client initialization"
      exports: ["getSupabaseClient"]
      min_lines: 10
    - path: "src/scrapers/db/operations.ts"
      provides: "Database upsert with dedupe_hash and sources JSONB conversion"
      exports: ["upsertListings", "markStaleListings"]
      min_lines: 60
    - path: ".github/workflows/scrape-yad2.yml"
      provides: "Scheduled GitHub Actions workflow"
      contains: "cron.*0 \\*/6"
    - path: "package.json"
      contains: "\"scrape\":"
  key_links:
    - from: "src/scrapers/index.ts"
      to: "src/scrapers/yad2.ts"
      via: "import scrapeYad2"
      pattern: "scrapeYad2\\(\\)"
    - from: "src/scrapers/index.ts"
      to: "src/scrapers/db/operations.ts"
      via: "upsertListings call"
      pattern: "upsertListings.*listings"
    - from: "src/scrapers/db/operations.ts"
      to: "@supabase/supabase-js"
      via: "supabase.from('listings').upsert"
      pattern: "\\.upsert.*onConflict.*dedupe_hash"
    - from: "src/scrapers/db/operations.ts"
      to: "sources JSONB"
      via: "convert flat fields to sources array"
      pattern: "sources:.*platform.*url.*scraped_at"
    - from: "src/scrapers/db/operations.ts"
      to: "dedupe_hash column"
      via: "upsert conflict detection"
      pattern: "onConflict.*dedupe_hash"
    - from: ".github/workflows/scrape-yad2.yml"
      to: "npm run scrape"
      via: "workflow run step"
      pattern: "npm run scrape"
---

<objective>
Integrate scraper with Supabase database and GitHub Actions scheduled workflow.

Purpose: Complete the data pipeline from Yad2 to database with dedupe_hash-based deduplication, sources JSONB format, stale listing detection using is_active/last_seen, and scheduled execution every 6 hours.
Output: Working end-to-end scraper pipeline with GitHub Actions workflow, database operations using Phase 2 schema columns, and monitoring.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-yad2-scraper/03-RESEARCH.md
@.planning/phases/03-yad2-scraper/03-01-SUMMARY.md
@.planning/phases/03-yad2-scraper/03-02-SUMMARY.md
@.planning/phases/03-yad2-scraper/03-03-SUMMARY.md
@src/scrapers/yad2.ts
@src/scrapers/types.ts
@src/scrapers/utils/hash.ts
@supabase/migrations/20260213010445_create_core_schema.sql
@supabase/migrations/20260213020000_add_scraper_fields.sql
@.github/workflows/deploy.yml
</context>

<tasks>

<task type="auto">
  <name>Create database client and operations</name>
  <files>src/scrapers/db/client.ts, src/scrapers/db/operations.ts</files>
  <action>
    Create two files:

    **1. src/scrapers/db/client.ts** - Supabase client initialization:
    - Import { createClient } from '@supabase/supabase-js'
    - Export function getSupabaseClient():
      - Read SUPABASE_URL and SUPABASE_SERVICE_KEY from process.env
      - Validate both are set (throw error if missing with helpful message)
      - Return createClient(url, serviceKey)
    - Use service_role key (not anon key) for write access

    **2. src/scrapers/db/operations.ts** - Database operations:

    Export async function upsertListings(listings: Listing[]): Promise<void>
    - Get Supabase client
    - For each listing:
      - Generate dedupe_hash using generateDedupeHash(address, rooms, size_sqm)
      - Convert flat source fields to sources JSONB array format (Phase 2 schema):
        - sources: [{ platform: source_platform, url: source_url, scraped_at: new Date().toISOString() }]
      - Upsert to 'listings' table:
        - Fields: id, address, city, price, rooms, size_sqm, floor, photos (JSONB array), sources (JSONB array), dedupe_hash, last_seen (new Date().toISOString()), is_active: true
        - DO NOT include flat source_url, source_platform, source_id (not in Phase 2 schema)
        - onConflict: 'dedupe_hash' (uses unique constraint from migration 03-01)
        - ignoreDuplicates: false (update existing records with new last_seen)
      - Log success/error for each listing
    - Batch if possible (Supabase supports array upsert), but handle errors individually

    Export async function markStaleListings(platform: string): Promise<void>
    - Get Supabase client
    - Calculate cutoff: 7 days ago (new Date(); date.setDate(date.getDate() - 7); date.toISOString())
    - Update query:
      - .from('listings')
      - .update({ is_active: false })
      - .eq('source_platform', platform) - NOTE: query sources JSONB using .contains or extract platform from JSONB
      - .lt('last_seen', cutoff)
      - .eq('is_active', true)
    - IMPORTANT: Since sources is JSONB array, use: .contains('sources', [{ platform }]) or use PostgreSQL JSONB query syntax
    - Log count of rows updated
    - Handle errors

    Import { log } from '../utils/logger' for logging
    Import { generateDedupeHash } from '../utils/hash'
    Import { Listing } from '../types'

    **Critical schema alignment:**
    - Phase 2 schema has: sources JSONB (not flat source_url/source_platform/source_id)
    - Phase 2 schema has: size_sqm (not size)
    - Phase 3 migration adds: dedupe_hash, is_active, last_seen
    - Upsert conflict detection uses dedupe_hash column directly on listings table
  </action>
  <verify>npx tsc --project tsconfig.scraper.json --noEmit</verify>
  <done>Database client and operations exist, implement upsert with dedupe_hash deduplication and sources JSONB conversion, stale marking uses is_active</done>
</task>

<task type="auto">
  <name>Create scraper entry point and npm script</name>
  <files>src/scrapers/index.ts, package.json</files>
  <action>
    **1. src/scrapers/index.ts** - Main execution entry point:
    - Import { scrapeYad2 } from './yad2'
    - Import { upsertListings, markStaleListings } from './db/operations'
    - Import { log } from './utils/logger'

    Export async function main():
      - Log: "Starting Yad2 scraper..."
      - Call scrapeYad2()
      - Log: "Scraped {count} listings"
      - Call upsertListings(listings)
      - Log: "Listings saved to database"
      - Call markStaleListings('yad2')
      - Log: "Stale listings marked inactive"
      - Log: "Scraper completed successfully"

    Error handling:
      - Wrap in try/catch
      - Log errors with full context
      - process.exit(1) on error (for GitHub Actions failure detection)
      - process.exit(0) on success

    Execute: if (require.main === module) { main() }

    **2. package.json** - Add scrape script:
    - Add to scripts: "scrape": "tsx src/scrapers/index.ts"
    - This allows: npm run scrape (for GitHub Actions and local testing)
  </action>
  <verify>
    npx tsc --project tsconfig.scraper.json --noEmit
    (Manual test with secrets: SUPABASE_URL=xxx SUPABASE_SERVICE_KEY=xxx npm run scrape - but don't run in automated verification without secrets)
  </verify>
  <done>Entry point exists, integrates scraper + database operations, npm run scrape works</done>
</task>

<task type="auto">
  <name>Create GitHub Actions scheduled workflow</name>
  <files>.github/workflows/scrape-yad2.yml</files>
  <action>
    Create .github/workflows/scrape-yad2.yml:

    **Trigger:**
    - schedule: cron: '0 */6 * * *' (every 6 hours at minute 0)
    - workflow_dispatch: {} (manual trigger for testing)

    **Job: scrape**
    - runs-on: ubuntu-latest
    - timeout-minutes: 30 (prevent hung workflows)

    **Steps:**
    1. Checkout repository (actions/checkout@v4)
    2. Setup Node.js 20 (actions/setup-node@v4)
    3. Install dependencies (npm ci)
    4. Run scraper (npm run scrape)
       - env:
         - SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
         - SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}

    **Note:** Workflow will fail until user adds GitHub Secrets (SUPABASE_URL, SUPABASE_SERVICE_KEY) in repo settings. Document this requirement in SUMMARY.

    Reference existing deploy.yml for action versions and structure.
  </action>
  <verify>
    .github/workflows/scrape-yad2.yml exists
    grep -q "cron.*0 \\*/6" .github/workflows/scrape-yad2.yml
    grep -q "npm run scrape" .github/workflows/scrape-yad2.yml
  </verify>
  <done>GitHub Actions workflow exists with 6-hour schedule, manual trigger, and Supabase secrets integration</done>
</task>

</tasks>

<verification>
- [ ] src/scrapers/db/client.ts initializes Supabase with service_role key
- [ ] src/scrapers/db/operations.ts implements upsertListings with dedupe_hash-based deduplication
- [ ] src/scrapers/db/operations.ts converts flat source fields to sources JSONB array
- [ ] src/scrapers/db/operations.ts uses size_sqm field (not size)
- [ ] src/scrapers/db/operations.ts uses onConflict: 'dedupe_hash' on listings table
- [ ] src/scrapers/db/operations.ts implements markStaleListings using is_active and last_seen
- [ ] src/scrapers/index.ts integrates scraper + database operations
- [ ] package.json includes "scrape" script using tsx
- [ ] .github/workflows/scrape-yad2.yml has cron schedule (0 */6 * * *)
- [ ] Workflow uses SUPABASE_URL and SUPABASE_SERVICE_KEY secrets
- [ ] Workflow has workflow_dispatch for manual testing
- [ ] TypeScript compiles all scraper code without errors
</verification>

<success_criteria>
End-to-end scraper pipeline is complete:
- Database client initializes with service_role key from env vars
- Upsert operation uses dedupe_hash column on listings table for conflict detection
- Source fields converted to sources JSONB array format matching Phase 2 schema
- Duplicate listings update last_seen timestamp instead of creating new rows
- Stale listings (not seen in 7 days) are marked inactive using is_active column
- Entry point integrates scraping, upserting, and stale marking
- GitHub Actions workflow runs scraper every 6 hours
- Workflow supports manual trigger for testing
- npm run scrape command works for local execution
</success_criteria>

<output>
After completion, create `.planning/phases/03-yad2-scraper/03-04-SUMMARY.md`
</output>
